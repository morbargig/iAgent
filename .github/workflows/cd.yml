name: ðŸš€ Continuous Deployment (CD)

on:
  # Trigger CD after successful CI on main branch
  workflow_run:
    workflows: ["ðŸ” Continuous Integration (CI)"]
    types: [completed]
    branches: [main]
  
  # Allow manual deployment
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_tests:
        description: 'Skip running tests before deployment'
        required: false
        default: false
        type: boolean

# Ensure only one deployment runs at a time
concurrency:
  group: deployment-${{ github.ref }}
  cancel-in-progress: false

env:
  NODE_VERSION: '18'
  # Environment-specific configurations
  PRODUCTION_URL: 'https://your-username.github.io/iAgent'
  STAGING_URL: 'https://staging.your-domain.com'

jobs:
  # Job 1: Pre-deployment Checks
  pre-deployment:
    name: ðŸ” Pre-deployment Verification
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    # Only run if CI passed or manual trigger
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    outputs:
      should_deploy: ${{ steps.check.outputs.should_deploy }}
      target_environment: ${{ steps.check.outputs.environment }}
      deployment_url: ${{ steps.check.outputs.deployment_url }}
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ” Check deployment conditions
        id: check
        run: |
          echo "ðŸ” Checking deployment conditions..."
          
          # Determine target environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENVIRONMENT="production"
          else
            ENVIRONMENT="staging"
          fi
          
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          
          # Set deployment URL based on environment
          if [[ "${ENVIRONMENT}" == "production" ]]; then
            echo "deployment_url=${{ env.PRODUCTION_URL }}" >> $GITHUB_OUTPUT
          else
            echo "deployment_url=${{ env.STAGING_URL }}" >> $GITHUB_OUTPUT
          fi
          
          echo "should_deploy=true" >> $GITHUB_OUTPUT
          echo "ðŸŽ¯ Target environment: ${ENVIRONMENT}"

      - name: ðŸ“‹ Display deployment info
        run: |
          echo "ðŸ“‹ Deployment Information:"
          echo "Environment: ${{ steps.check.outputs.environment }}"
          echo "URL: ${{ steps.check.outputs.deployment_url }}"
          echo "Branch: ${{ github.ref_name }}"
          echo "Commit: ${{ github.sha }}"

  # Job 2: Build for Production
  build-production:
    name: ðŸ—ï¸ Production Build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [pre-deployment]
    if: needs.pre-deployment.outputs.should_deploy == 'true'
    
    strategy:
      matrix:
        project: ['frontend', 'backend']
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: ðŸ“¦ Install dependencies
        run: npm ci --prefer-offline --no-audit --production=false

      - name: ðŸ” Cache Nx computation cache
        uses: actions/cache@v4
        with:
          path: .nx/cache
          key: nx-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-${{ github.sha }}
          restore-keys: |
            nx-${{ runner.os }}-${{ hashFiles('**/package-lock.json') }}-

      - name: ðŸ—ï¸ Build ${{ matrix.project }} for production
        run: |
          echo "ðŸ—ï¸ Building ${{ matrix.project }} for production..."
          if [[ "${{ matrix.project }}" == "frontend" ]]; then
            npx nx build frontend --configuration=production
          else
            npx nx build backend --configuration=production
          fi
        env:
          # Frontend-specific environment variables
          VITE_BASE_URL: ${{ needs.pre-deployment.outputs.deployment_url }}
          VITE_API_BASE_URL: ${{ needs.pre-deployment.outputs.deployment_url }}/api
          VITE_ENVIRONMENT: ${{ needs.pre-deployment.outputs.target_environment }}
          
          # Backend-specific environment variables
          NODE_ENV: production

      - name: ðŸ“Š Analyze build output (${{ matrix.project }})
        run: |
          echo "ðŸ“Š Analyzing build output for ${{ matrix.project }}..."
          if [[ -d "dist/apps/${{ matrix.project }}" ]]; then
            echo "ðŸ“ Build directory contents:"
            ls -la dist/apps/${{ matrix.project }}
            echo "ðŸ“ Build size:"
            du -sh dist/apps/${{ matrix.project }}
            
            if [[ "${{ matrix.project }}" == "frontend" ]]; then
              echo "ðŸ—‚ï¸ Frontend assets:"
              find dist/apps/frontend -name "*.js" -o -name "*.css" | head -10
            fi
          else
            echo "âŒ Build directory not found!"
            exit 1
          fi

      - name: ðŸ§ª Smoke test build (${{ matrix.project }})
        run: |
          echo "ðŸ§ª Running smoke tests for ${{ matrix.project }}..."
          if [[ "${{ matrix.project }}" == "frontend" ]]; then
            # Check if main files exist
            if [[ -f "dist/apps/frontend/index.html" ]]; then
              echo "âœ… Frontend HTML file exists"
            else
              echo "âŒ Frontend HTML file missing"
              exit 1
            fi
          elif [[ "${{ matrix.project }}" == "backend" ]]; then
            # Check if main.js exists
            if [[ -f "dist/apps/backend/main.js" ]]; then
              echo "âœ… Backend main.js exists"
            else
              echo "âŒ Backend main.js missing"
              exit 1
            fi
          fi

      - name: ðŸ“¦ Create deployment package
        run: |
          echo "ðŸ“¦ Creating deployment package for ${{ matrix.project }}..."
          cd dist/apps/${{ matrix.project }}
          tar -czf ../../../${{ matrix.project }}-deployment.tar.gz .
          cd ../../..
          echo "ðŸ“ Package size: $(du -sh ${{ matrix.project }}-deployment.tar.gz)"

      - name: ðŸ“‹ Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: production-build-${{ matrix.project }}
          path: |
            dist/apps/${{ matrix.project }}
            ${{ matrix.project }}-deployment.tar.gz
          retention-days: 30

  # Job 3: Security & Quality Checks for Production
  production-quality-gate:
    name: ðŸ›¡ï¸ Production Quality Gate
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [build-production]
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download frontend build
        uses: actions/download-artifact@v4
        with:
          name: production-build-frontend
          path: dist/apps/frontend

      - name: ðŸ”’ Security scan on production build
        run: |
          echo "ðŸ”’ Scanning production build for security issues..."
          
          # Check for sensitive information in built files
          echo "ðŸ” Checking for sensitive data..."
          if grep -r "password\|secret\|key\|token" dist/apps/frontend/ --exclude-dir=node_modules || true; then
            echo "âš ï¸ Potential sensitive data found in build"
          else
            echo "âœ… No obvious sensitive data found"
          fi

      - name: ðŸ“Š Performance audit on build
        run: |
          echo "ðŸ“Š Analyzing production build performance..."
          
          # Check bundle sizes
          echo "ðŸ“ Bundle size analysis:"
          find dist/apps/frontend -name "*.js" -exec wc -c {} + | sort -n
          
          # Check for large files (> 1MB)
          echo "ðŸ” Checking for large files (>1MB):"
          find dist/apps/frontend -size +1M -type f || echo "âœ… No large files found"

      - name: ðŸ§ª Final smoke tests
        run: |
          echo "ðŸ§ª Running final smoke tests..."
          
          # Validate HTML structure
          if [[ -f "dist/apps/frontend/index.html" ]]; then
            echo "âœ… HTML file exists"
            
            # Check for required meta tags
            if grep -q "viewport" dist/apps/frontend/index.html; then
              echo "âœ… Viewport meta tag found"
            else
              echo "âš ï¸ Viewport meta tag missing"
            fi
          fi

  # Job 4: Deploy to GitHub Pages (Production)
  deploy-production:
    name: ðŸŒ Deploy to Production
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [pre-deployment, build-production, production-quality-gate]
    if: needs.pre-deployment.outputs.target_environment == 'production'
    
    environment:
      name: production
      url: ${{ needs.pre-deployment.outputs.deployment_url }}
    
    permissions:
      contents: write
      pages: write
      id-token: write
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download frontend build
        uses: actions/download-artifact@v4
        with:
          name: production-build-frontend
          path: dist/apps/frontend

      - name: ðŸ”§ Prepare deployment files
        run: |
          echo "ðŸ”§ Preparing files for deployment..."
          
          # Create CNAME file if custom domain is used
          # echo "your-domain.com" > dist/apps/frontend/CNAME
          
          # Create .nojekyll file to bypass Jekyll processing
          touch dist/apps/frontend/.nojekyll
          
          # Create robots.txt
          cat > dist/apps/frontend/robots.txt << EOF
          User-agent: *
          Allow: /
          Sitemap: ${{ needs.pre-deployment.outputs.deployment_url }}/sitemap.xml
          EOF
          
          echo "âœ… Deployment files prepared"

      - name: ðŸš€ Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./dist/apps/frontend
          # Custom domain setup (uncomment if needed)
          # cname: your-domain.com
          
          # Git commit settings
          commit_message: 'ðŸš€ Deploy ${{ github.sha }}'
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'

      - name: ðŸ“‹ Deployment summary
        run: |
          echo "ðŸ“‹ Deployment Summary:"
          echo "âœ… Frontend deployed to: ${{ needs.pre-deployment.outputs.deployment_url }}"
          echo "ðŸ“Š Build size: $(du -sh dist/apps/frontend)"
          echo "ðŸ• Deployed at: $(date)"
          echo "ðŸ“ Commit: ${{ github.sha }}"

  # Job 5: Deploy to Staging (Alternative environment)
  deploy-staging:
    name: ðŸ§ª Deploy to Staging
    runs-on: ubuntu-latest
    timeout-minutes: 10
    needs: [pre-deployment, build-production]
    if: needs.pre-deployment.outputs.target_environment == 'staging'
    
    environment:
      name: staging
      url: ${{ needs.pre-deployment.outputs.deployment_url }}
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ“¥ Download frontend build
        uses: actions/download-artifact@v4
        with:
          name: production-build-frontend
          path: dist/apps/frontend

      - name: ðŸ§ª Deploy to staging environment
        run: |
          echo "ðŸ§ª Deploying to staging environment..."
          echo "ðŸ“ Staging URL: ${{ needs.pre-deployment.outputs.deployment_url }}"
          echo "â„¹ï¸ This is a placeholder for staging deployment"
          echo "ðŸ”§ In a real scenario, this would deploy to your staging server"
          
          # Example staging deployment commands:
          # rsync -avz dist/apps/frontend/ user@staging-server:/var/www/html/
          # ssh user@staging-server "sudo systemctl reload nginx"

  # Job 6: Post-deployment Tests
  post-deployment-tests:
    name: ðŸ§ª Post-deployment Testing
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: [deploy-production, pre-deployment]
    if: always() && (needs.deploy-production.result == 'success' || needs.deploy-staging.result == 'success')
    
    steps:
      - name: ðŸ“¥ Checkout repository
        uses: actions/checkout@v4

      - name: ðŸ”§ Setup Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸŒ Wait for deployment to be available
        run: |
          echo "ðŸŒ Waiting for deployment to be available..."
          DEPLOYMENT_URL="${{ needs.pre-deployment.outputs.deployment_url }}"
          
          for i in {1..10}; do
            if curl -s --head "$DEPLOYMENT_URL" | head -n 1 | grep -q "200 OK"; then
              echo "âœ… Deployment is live!"
              break
            else
              echo "â³ Waiting for deployment... (attempt $i/10)"
              sleep 30
            fi
          done

      - name: ðŸ§ª Run end-to-end tests
        run: |
          echo "ðŸ§ª Running end-to-end tests against deployed application..."
          DEPLOYMENT_URL="${{ needs.pre-deployment.outputs.deployment_url }}"
          
          # Basic connectivity test
          if curl -s "$DEPLOYMENT_URL" | grep -q "iAgent"; then
            echo "âœ… Basic connectivity test passed"
          else
            echo "âŒ Basic connectivity test failed"
            exit 1
          fi

      - name: ðŸŽï¸ Performance testing
        run: |
          echo "ðŸŽï¸ Running performance tests..."
          npm install -g lighthouse
          
          DEPLOYMENT_URL="${{ needs.pre-deployment.outputs.deployment_url }}"
          lighthouse "$DEPLOYMENT_URL" --only-categories=performance --output=json --output-path=./lighthouse-results.json || true
          
          if [[ -f "./lighthouse-results.json" ]]; then
            echo "ðŸ“Š Lighthouse results generated"
          fi

      - name: ðŸ“‹ Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: post-deployment-test-results
          path: |
            lighthouse-results.json
            test-results.xml
          retention-days: 30

  # Job 7: Deployment Notification
  notify-deployment:
    name: ðŸ“¢ Deployment Notification
    runs-on: ubuntu-latest
    timeout-minutes: 5
    needs: [pre-deployment, deploy-production, deploy-staging, post-deployment-tests]
    if: always()
    
    steps:
      - name: ðŸ“¢ Success notification
        if: contains(needs.*.result, 'success') && !contains(needs.*.result, 'failure')
        run: |
          echo "ðŸ“¢ Deployment Success Notification"
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ URL: ${{ needs.pre-deployment.outputs.deployment_url }}"
          echo "ðŸŽ¯ Environment: ${{ needs.pre-deployment.outputs.target_environment }}"
          echo "ðŸ“ Commit: ${{ github.sha }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          echo "ðŸ• Time: $(date)"

      - name: ðŸ“¢ Failure notification
        if: contains(needs.*.result, 'failure')
        run: |
          echo "ðŸ“¢ Deployment Failure Notification"
          echo "âŒ Deployment failed!"
          echo "ðŸ” Please check the workflow logs for details"
          echo "ðŸŽ¯ Environment: ${{ needs.pre-deployment.outputs.target_environment }}"
          echo "ðŸ“ Commit: ${{ github.sha }}"
          echo "ðŸ‘¤ Triggered by: ${{ github.actor }}"
          
          # In a real scenario, you might send notifications to Slack, Discord, email, etc.
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"Deployment failed for iAgent"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

      - name: ðŸ“Š Deployment summary
        if: always()
        run: |
          echo "ðŸ“Š Deployment Pipeline Summary:"
          echo "Pre-deployment: ${{ needs.pre-deployment.result }}"
          echo "Production Deploy: ${{ needs.deploy-production.result }}"
          echo "Staging Deploy: ${{ needs.deploy-staging.result }}"
          echo "Post-deployment Tests: ${{ needs.post-deployment-tests.result }}" 